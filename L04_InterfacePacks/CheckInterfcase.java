

interface A {

            int sum(int x, int y);

}

class B implements A{

            public int diff(int x, int y){return x - y;}

            public int sum(int x, int y){return x + y;}

}

class C extends B{

            public int mult(int x, int y){return x * y;}

            public int diff(int x, int y){return y - x;}

}

/*
Тип объекта накладывает ограничение на использование его конкретных методов(sum, diff или mult), т.е. могут быть использованы только методы, которые присутствуют у типа объекта.

В случае наследования от класса с одноименным методом происходит т.н. переопределение метода, таким образом в объекте bC используется версия diff из C

С extends B, поэтому C может оперировать 3 методами: mult, diff и sum,  метод sum(inx x, int y) наследуется у B



Я бы сказал так. Если у нас сохраняется та же структура

A <- - B <- C

то B bC = new C(); означает, что мы будем иметь в bC ТОЛЬКО те методы, которые доступны в B, но, на всякий случай, если некоторые из методов доступных в B переопределены в C, то мы будем пользоваться именно этой, переопределенной в С реализацией. Ну или так - в bC "перетираются" или "перезаписываются" созданные методы в B теми же методами, но с другой реализацией в С, однако новые методы, которые есть в С нам доступны не будут в bC.

Class One {
MethOne(){};
} 
Class Two extends One{
MethTwo();
}
One a1 = new Two();//Создаю объект a1


Коллеги внимание - я создаю объект а1. Он принадлежит к типу Two, но он даёт собой ссылку на One. И тут уместны два постулата:
1. Ссылку можно указать на любой родительский класс. Всё будет нормально компилироваться.
2. Если метод не описан в классе по ссылке (в нашем примере Class Onе ), или его родительском классе если таковой имеется, то вызов метода выкинет ошибку.

В нашем примере:

a1.MethOne(); //Работает. 
a1.MethTwo(); //Выбросит ошибку, потому что этот метод не описан в классе ссылке, то есть в классе One

ороче - тип ссылки задаёт интерфейс (какие методы можно вызвать), а реализация метода уже зависит от типа объекта.

Тип ссылки задает интерфейс -> те методы которые есть у объекта, но реализация этих методов будет зависеть от типа объекта
Приведу на одном примере

B bC= new C(); -> содержит 2 метода

class B implements A{

            public int diff(int x, int y){return x - y;}

            public int sum(int x, int y){return x + y;}

}
Но поскольку реализация у типа объекта С отличается, то в В реализация измениться и будет такая как в С, он не будет иметь mult, но diff будет как последний определенный в С
Надеюсь объяснил доступно
*/


class CheckInterface{

	public static void main(String[] args){
A aB = new B();

A aC = new C();

B bB= new B();

B bC= new C();

C cC = new C();

 }

}
