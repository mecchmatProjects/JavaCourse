
    How can we make sure main() is the last thread to finish in Java Program?
    Как thread могут взаимодействовать с друг другом?
    Why thread communication methods wait(), notify() and notifyAll() are in Object class?
    Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block?
    Почему Thread sleep() и yield() методы статические?
    Как обеспечить thread safety в Java?
    Что такое volatile keyword в Java
    Что предпочтительнее Synchronized метод или Synchronized блок?
    Что такое ThreadLocal?
    Что такое Thread Group? Стоит ли их использовать?
    Что такое Java Thread Dump, Как получить Java Thread dump программы?
    Что такое Java Timer Class? Как запустить task после определенного интервала времени?
    Что такое Thread Pool? Как создать Thread Pool в Java?
    Что произойдет если не override метод run() у класса Thread ?

    В чем разница между Process и Thread?
    В чем преимущества multi-threaded программирования?
    В чем разница между user Thread и daemon Thread?
    Как создать Thread в Java?
    Какие есть различные состояние у Thread?
    Можно ли вызвать run() метод у Thread класса?
    Как можно остановить выполнения Thread на определенное время?
    Что такое Thread Priority?
    Что такое Thread Scheduler и Time Slicing?
    Что такое context-switching в multi-threading?
    Как создать daemon thread в Java?




Processes and threads — разница в том что процессы это независимые приложения (управляются ОС), thread это отдельные легковесные нити для параллельного выполнения в Java (управляются JVM и программистом).

Преимущества multi-threaded программирования — правильно написанная multi-threaded приложение работает быстрее за счет использования нескольких процессоров и процессор не простаивает пока один из потоков ожидает получения ресурсов.

daemon thread — thread, который работает в фоновом режиме и JVM не требуется ждать его окончания, чтобы завершить работу. Можно сделать любой thread демоном используя setDaemon(true), но этот метод должен вызваться до запуска thread с помощью start.

ThreadGroup — устаревший API, который предоставляет информацию о группе потоков. Сейчас не рекомендуется к использованию.
Java Thread Dump — получение информации о состоянии всех потоков JVM и поиска deadlock ситуаций или других проблем с многопоточностью. Есть много способов генерации Java Thread Dump, например в Java 8 можно сгененерить с помощью команды jcmd PID имя_файла_для_дампа или kill -3 PID, либо с помощью любого профайлера (VisualVM, jstack и т.д.)

Способы создания thread в Java SE:

1. Создать класс, реализующий Runnable интерфейс, реализовать метод run и запустить thread методом start, обратите внимание вызвать метод run неправильно, в этом случае не будет создан новый thread (хотя он отработает).

2. Создать класс-наследника от класса Thread, также переопределить метод run и запустить thread методом start. В отличии от способа 1, класс Thread предоставляет ряд уже определенных методов, однако реализация интерфейса дает больше гибкости (так как множественное наследование в Java невозможно),

3. Использовать Executors, который предоставляет высокоуровневый аналог способов 1-2.

Методы работы с Thread

1. sleep — останавливает выполнение на указанное время, либо до момента когда Thread не был прерван,

2. interrupt — посылает сигнал в Thread, о том что тот должен быть прекращен (мягкое прерывание потока), поток должен поддерживать обработку данного сигнала (опрашивая периодически флаг Thread.interrupted),

3. join — ждет окончания другого потока или сигнала остановки треда,

4. synchronized — ключевое слово перед методами либо блок synchronized(ссылка) {...}

5. wait — остановка треда и ожидания вызова notify или notifyAll.

6. stop (deprecated) — немедленная остановка треда, крайне не рекомендуется использовать, так как состояние общих переменных может оказаться в некорректном состоянии.

7. suspend (deprecated) и resume (deprecated) — временная остановка потока и его восстановление. Не рекомендуется использовать так как очень часто это приводит к deadlock«у (ресурсы при временной остановки остаются заблокированными)

8. setUncaughtExceptionHandler — возможность добавить обработчик исключений в данный поток.

Особые переменные для thread:

ThreadLocal — переменная локальная только для одного thread'а, каждый thread будет видеть свое значение.
volatile — ключевое слово, которое отмечает переменные, которые все потоки читают из памяти (heap) и не кэшируют. Это не решает все проблемы синхронизации, однако обычные переменные потоки имеют право за кэшировать и вообще не обновлять долгое время. Для более надежной работы с несколькими thread'ами стоит использовать Atomic переменные или блоки синхронизации.



Atomic операции и классы

Читать...
Возможные вопросы

    Какие типы данных в Java являются атомарными для операций чтения/записи с точки зрения многопоточности?
    Что такое atomic operation?
    Какие atomic классы в Java Concurrency API вы знаете?



Atomic операции — операции которые выполняются или не выполняются целиком.

Следующие операции atomic:

1. Чтение и запись ссылок и примитивных типов (кроме long и double)

2. Чтение и запись всех переменных отмеченных как volatile (так как запись и чтение выполняется как happens-before relationship, то есть в гарантированном порядке),

Atomic переменные для простого способа создания переменных общих для разных тредов с минимизаций синхронизации и ошибок. Подробнее см javadoc



Liveness problem


Читать...
Возможные вопросы

    Что такое Deadlock? Как анализировать и избегать deadlock?
    Какие проблемы при многопоточности бывают кроме Deadlock?
    Что такое Starvation и Livelock?




Проблемы при выполнении у многопоточных приложений (liveness problem):

1. Deadlock — блокировка двух разных ресурсов двумя тредами с бесконечным ожиданием освобождения,

2, Starvation — один из потоков блокирует часто используемый ресурс на долгое время заставляя остальные потоки ждать освобождения

3. Livelock — когда два потока освобождают и занимают одни и те же ресурсы в ответ на действия друг друга, при этом не могут занять все необходимые ресурсы и продолжить выполнения.


Стратегия определения неизменяемых объектов


Для создания неизменяемых объектов требуется придерживаться следующих правил:

1. Не предоставлять „setter“ методов, все поля должны быть final и private,

2. Не позволять наследникам переопределять методы, простейший путь определить класс как final. Более сложный путь определить конструктор как private и создать объекты с помощью factory метода.

3. Поля, включая поля с ссылками на mutable objects не должны позволять изменения:

4. Не предоставлять методов по изменению mutable объектов,.

5. Не отдавать ссылок на mutable объекты, при необходимости создавать копии и передавать копии объектов.

Высокоуровневые средства работы с многопоточностью

Читать...
Возможные вопросы

    Что такое Lock interface в Java Concurrency API? Какие его плюсы по сравнению synchronization?
    Что такое Executors Framework?
    Что такое BlockingQueue? Как избежать Producer-Consumer проблему используя Blocking Queue?
    Что такое Callable и Future?
    Что такое FutureTask класс?
    Что такое Concurrent Collection класс?
    Что такое Executors класс?
    Какие улучшению в Concurrency API есть в Java 8?





Читать...
В отличие от synchronized блоков и т.п. низкоуровневых средств работы с многопоточными приложениями, J8SE так же предоставляет много средств для более удобных средств работы с многопоточными приложениями в отличие от низкоуровневых средств ручного управления тредами и блокировками.

Основные виды:

1. Task scheduling framework ( Executor) — интерфейс для запуска заданий в новом треде с запуском по расписанию, управлением асинхорными тасками и т.п.

2. ForkJoinPool — класс, реализующий Executors и ExecutorService для реализации многопоточных стримов и т.п. Он разработан для для эффективного распараллеливания большого количества небольших по времени задач, используя пул тредов (используется технология work-stealing).

3. Lock объекты — удобный способ блокировки объектов и передачи данных между тредами,

4. Executors определяет высокоуровневый способ создания и управления тредами с помощью пула объектов,

5. Многопоточные коллекции — коллекции, работающие в многопоточном приложении (Concurrent Collection, BlockingQueue, Если вам интересны более подробная информация о интерфейсах и коллекциях из java.util.concurrent советую прочитать раздел коллекции этой статьи или вот эту статью.),

6. Atomic переменные для простого способа создания переменных общих для разных тредов с минимизаций синхронизации и ошибок. Подробнее см javadoc

7. ThreadLocalRandom (с JDK 7) предоставляет эффективный способ создания псевдослучайных чисел для многопоточных программ.
