The chain of responsibility is an object-oriented design pattern that processes a request through a series of handlers (a chain). The request is passed from one handler to another and processed by one or all of these handlers in the chain.

As a rule, an implementation of this pattern requires the following classes and methods:

    a general handler is an abstract class or interface with a method handle/process/etc and a method to set the next handler;
    one or more concrete handlers that implement the general handler.

The functional style allows us to implement this pattern easier. Instead of writing all concrete handlers we can write lambda expressions (or method references). For setting the next handler it's possible to use function composition in similar to functions way.

import java.util.Arrays;
import java.util.EnumSet;
import java.util.function.Consumer;

@FunctionalInterface
public interface Logger {
    public enum LogLevel {
        INFO, DEBUG, WARNING, ERROR, FUNCTIONAL_MESSAGE, FUNCTIONAL_ERROR;

        public static LogLevel[] all() {
            return values();
        }
    }

    abstract void message(String msg, LogLevel severity);

    default Logger appendNext(Logger nextLogger) {
        return (msg, severity) -> {
            message(msg, severity);
            nextLogger.message(msg, severity);
        };
    }

    static Logger writeLogger(LogLevel[] levels, Consumer<String> stringConsumer) {
        EnumSet<LogLevel> set = EnumSet.copyOf(Arrays.asList(levels));
        return (msg, severity) -> {
            if (set.contains(severity)) {
                stringConsumer.accept(msg);
            }
        };
    }

    static Logger consoleLogger(LogLevel... levels) {
        return writeLogger(levels, msg -> System.err.println("Writing to console: " + msg));
    }

    static Logger emailLogger(LogLevel... levels) {
        return writeLogger(levels, msg -> System.err.println("Sending via email: " + msg));
    }

    static Logger fileLogger(LogLevel... levels) {
        return writeLogger(levels, msg -> System.err.println("Writing to Log File: " + msg));
    }
}

class Runner {
    public static void main(String[] args) {
        // Build an immutable chain of responsibility
        Logger logger = consoleLogger(LogLevel.all())
                .appendNext(emailLogger(LogLevel.FUNCTIONAL_MESSAGE, LogLevel.FUNCTIONAL_ERROR))
                .appendNext(fileLogger(LogLevel.WARNING, LogLevel.ERROR));

        // Handled by consoleLogger since the console has a LogLevel of all
        logger.message("Entering function ProcessOrder().", LogLevel.DEBUG);
        logger.message("Order record retrieved.", LogLevel.INFO);

        // Handled by consoleLogger and emailLogger since emailLogger implements Functional_Error & Functional_Message
        logger.message("Unable to Process Order ORD1 Dated D1 For Customer C1.", LogLevel.FUNCTIONAL_ERROR);
        logger.message("Order Dispatched.", LogLevel.FUNCTIONAL_MESSAGE);

        // Handled by consoleLogger and fileLogger since fileLogger implements Warning & Error
        logger.message("Customer Address details missing in Branch DataBase.", LogLevel.WARNING);
        logger.message("Customer Address details missing in Organization DataBase.", LogLevel.ERROR);
    }
}


The design problem

There is a class called Request(data: String) for representing some XML requests in a payment system. It has a getter for the data field and a constructor with a single argument.

The following is what the value of data looks like in a human-readable format (it is a single line string when processing).

<request>
  <transaction>
    <type>payment</type>
    <sum>100000</sum>
    <order_id>e94dc619-6172-4ffe-aae8-63112c551570</order_id>
    <desc>We'd like to buy an elephant</desc>
  </transaction>
  <digest>CZVMYTgc3iiOdJjFP+6dhQ==</digest>
</request>

You must implement the chain of responsibility pattern in the functional style for stage-by-stage request creating.

1) Write the RequestHandler interface with a single abstract method called handle and one default method; the first method is needed to use lambda expressions. It should accept a Request object and then return a new Request with changed data. The second method is used to combine several handlers into a single one.

2) Create commonRequestHandler that is combined from three existing handlers: wrapInTransactionTag, createDigest and wrapInRequestTag.

It is important to use the provided template for your solution. Please, do not change it and read comments within the code. The template is long enough, scroll it to the bottom. All comments where your code is expected start with !!!

You can look at an example in the next step.

Keep in mind, all handlers have been already implemented and they are available for you. You need to write only a suitable functional interface and compose all existing handlers as functions into one commonRequestHandler to follow the described algorithm.



The algorithm for creating an XML request

﻿0) Initial request data looks like this shown below (it contains only business data).

<type>payment</type><sum>100000</sum><order_id>e94dc619-6172-4ffe-aae8-63112c551570</order_id><desc>We'd like to buy an elephant</desc>

​1) First, a tag <transaction>...</transaction> is added as border of the data (data is wrapped in the tag). The result:

<transaction><type>payment</type><sum>100000</sum><order_id>e94dc619-6172-4ffe-aae8-63112c551570</order_id><desc>We'd like to buy an elephant</desc></transaction>

​2) Then, a digest (MD5) is calculated for entire data created on the previous stage and added as the new digest <digest>...</digest>. Here is the result:

<transaction><type>payment</type><sum>100000</sum><order_id>e94dc619-6172-4ffe-aae8-63112c551570</order_id><desc>We'd like to buy an elephant</desc></transaction><digest>CZVMYTgc3iiOdJjFP+6dhQ==</digest>

3) After that, the data is wrapped in a tag <request>...</request> as shown below. The request is completed.

<request><transaction><type>payment</type><sum>100000</sum><order_id>e94dc619-6172-4ffe-aae8-
63112c551570</order_id><desc>We'd like to buy an elephant</desc></transaction>
<digest>CZVMYTgc3iiOdJjFP+6dhQ==</digest></request>

​So, if you have a request data as shown in stage 0, the algorithm should generate the result as shown in stage 3.

Note, each stage is already implemented for you in a specific RequestHandler.



Archetype:
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
.....
        default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }
.....
}


/**
 * It represents a handler and has two methods: one for handling requests and other for combining handlers
 */
@FunctionalInterface
interface RequestHandler {

    // !!! write a method handle that accept request and returns new request here
    // it allows to use lambda expressions for creating handlers below
    Request handle (Request req);
    // !!! write a default method for combining this and other handler single one
    // the order of execution may be any but you need to consider it when composing handlers
    // the method may has any name
    default RequestHandler andThen (RequestHandler next) {return (Request req)-> next.handle(handle(req));}
}

/**
 * Accepts a request and returns new request with data wrapped in the tag <transaction>...</transaction>
 */
final static RequestHandler wrapInTransactionTag =
        (req) -> new Request(String.format("<transaction>%s</transaction>", req.getData()));

/**
 * Accepts a request and returns a new request with calculated digest inside the tag <digest>...</digest>
 */
final static RequestHandler createDigest =
        (req) -> {
            String digest = "";
            try {
                final MessageDigest md5 = MessageDigest.getInstance("MD5");
                final byte[] digestBytes = md5.digest(req.getData().getBytes("UTF-8"));
                digest = new String(Base64.getEncoder().encode(digestBytes));
            } catch (Exception ignored) { }
            return new Request(req.getData() + String.format("<digest>%s</digest>", digest));
        };

/**
 * Accepts a request and returns a new request with data wrapped in the tag <request>...</request>
 */
final static RequestHandler wrapInRequestTag =
        (req) -> new Request(String.format("<request>%s</request>", req.getData()));

/**
 * It should represents a chain of responsibility combined from another handlers.
 * The format: commonRequestHandler = handler1.setSuccessor(handler2.setSuccessor(...))
 * The combining method setSuccessor may has another name
 */
final static RequestHandler commonRequestHandler = wrapInTransactionTag.andThen(createDigest).andThen(wrapInRequestTag);
    // !!! write the combining of existing handlers here

/**
 * Immutable class for representing requests.
 * If you need to change the request data then create new request.
 */
static class Request {
    private final String data;

    public Request(String requestData) {
        this.data = requestData;
    }

    public String getData() {
        return data;
    }
}


